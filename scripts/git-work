#!/usr/bin/env bash
set -euo pipefail

# git-work - Git worktree management tool with tmux integration
# Version: 1.0.0

SCRIPT_NAME="git work"
VERSION="1.0.0"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${GREEN}→${NC} $1"
}

warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

usage() {
    cat << EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
  start <branch|origin/branch> [dir] [base]
    Create a new worktree for the specified branch
    
    Arguments:
      branch         Local branch name or origin/branch for remote branch
      dir            Worktree directory (default: ../<repo>--<branch>)
      base           Base branch for new branches (default: HEAD or origin/main)
    
    Examples:
      git work start feature-x                    # New branch from HEAD
      git work start origin/feature-y             # From remote branch
      git work start hotfix ../hotfix-dir main    # Custom dir and base
  
  list
    List all worktrees (alias for git worktree list)
    
    Examples:
      git work list                                # List all worktrees
      git work list --porcelain                    # Machine-readable format
  
  move <branch|number>
    Move to a different worktree
    
    Arguments:
      branch         Branch name or worktree number from list (required)
    
    Examples:
      git work move feature-x                     # Move to specific branch
      git work move 2                             # Move to worktree number 2 from list
  
  back
    Return to the main repository from a worktree
    (Assumes worktree naming pattern: <repo>--<branch>)
  
  finish [branch|number]
    Remove a worktree and return to the main repository
    
    Arguments:
      branch         Branch name or worktree number from list (optional)
                     If not specified, removes current worktree
    
    Examples:
      git work finish                             # Remove current worktree
      git work finish feature-x                   # Remove specific branch's worktree
      git work finish 2                           # Remove worktree number 2 from list

Version: $VERSION
EOF
}

# Get repository name from current directory
get_repo_name() {
    local repo_path
    repo_path=$(git rev-parse --show-toplevel 2>/dev/null) || error "Not in a git repository"
    basename "$repo_path"
}

# Sanitize branch name for directory naming
sanitize_branch_name() {
    echo "$1" | sed 's/\//-/g'
}

# Check if branch exists locally
branch_exists() {
    git show-ref --verify --quiet "refs/heads/$1"
}

# Check if we're in a worktree
is_worktree() {
    git rev-parse --is-inside-work-tree &>/dev/null && \
    [ -n "$(git rev-parse --git-common-dir 2>/dev/null)" ] && \
    [ "$(git rev-parse --git-common-dir)" != "$(git rev-parse --git-dir)" ]
}

# Get worktree path for a given branch
get_worktree_path() {
    local branch="$1"
    git worktree list --porcelain | awk -v branch="$branch" '
        /^worktree / { path = $2 }
        /^branch / && $2 == "refs/heads/" branch { print path; exit }
    '
}

# List all worktrees with formatting
list_worktrees() {
    git worktree list | while read -r path hash rest; do
        # Extract branch name from [branch] format
        if [[ "$rest" =~ \[([^\]]+)\] ]]; then
            local branch="${BASH_REMATCH[1]}"
            echo "$branch|$path|$hash"
        fi
    done
}

# Subcommand: start
cmd_start() {
    local branch_arg="${1:-}"
    local dir_arg="${2:-}"
    local base_arg="${3:-}"
    
    [ -z "$branch_arg" ] && error "Branch name required. See '$SCRIPT_NAME --help'"
    
    local repo_name
    repo_name=$(get_repo_name)
    
    local branch_name
    local needs_fetch=false
    local needs_create=false
    local remote_branch=""
    
    # Parse branch argument
    if [[ "$branch_arg" =~ ^origin/(.+)$ ]]; then
        # Remote branch specified
        branch_name="${BASH_REMATCH[1]}"
        remote_branch="origin/$branch_name"
        needs_fetch=true
        
        info "Fetching remote branch: $remote_branch"
        git fetch origin "$branch_name" || error "Failed to fetch $remote_branch"
        
        if ! branch_exists "$branch_name"; then
            needs_create=true
        fi
    else
        # Local branch specified
        branch_name="$branch_arg"
        
        if ! branch_exists "$branch_name"; then
            needs_create=true
            
            # Determine base branch
            if [ -z "$base_arg" ]; then
                # Try origin/main first, then current HEAD
                if git show-ref --verify --quiet "refs/remotes/origin/main"; then
                    base_arg="origin/main"
                    info "Using origin/main as base branch"
                else
                    base_arg="HEAD"
                    info "Using current HEAD as base branch"
                fi
            fi
            
            # Fetch base if it's a remote branch
            if [[ "$base_arg" =~ ^origin/(.+)$ ]]; then
                info "Fetching base branch: $base_arg"
                git fetch origin "${BASH_REMATCH[1]}" || error "Failed to fetch $base_arg"
            fi
        fi
    fi
    
    # Determine worktree directory
    local worktree_dir
    if [ -n "$dir_arg" ]; then
        worktree_dir="$dir_arg"
    else
        local sanitized_branch
        sanitized_branch=$(sanitize_branch_name "$branch_name")
        worktree_dir="../${repo_name}--${sanitized_branch}"
    fi
    
    # Create worktree
    if [ -d "$worktree_dir" ]; then
        error "Directory already exists: $worktree_dir"
    fi
    
    if [ "$needs_create" = true ]; then
        if [ -n "$remote_branch" ]; then
            # Create from remote branch
            info "Creating worktree with new branch '$branch_name' from '$remote_branch'"
            git worktree add -b "$branch_name" "$worktree_dir" "$remote_branch" || \
                error "Failed to create worktree"
        else
            # Create from base
            info "Creating worktree with new branch '$branch_name' from '$base_arg'"
            git worktree add -b "$branch_name" "$worktree_dir" "$base_arg" || \
                error "Failed to create worktree"
        fi
    else
        # Use existing branch
        info "Creating worktree for existing branch '$branch_name'"
        git worktree add "$worktree_dir" "$branch_name" || \
            error "Failed to create worktree"
    fi
    
    info "Worktree created at: $worktree_dir"
    
    # Get absolute path for the worktree
    local abs_worktree_dir
    abs_worktree_dir=$(cd "$worktree_dir" && pwd)
    
    # Open tmux pane if in tmux session
    if [ -n "${TMUX:-}" ]; then
        info "Opening new tmux pane in worktree directory"
        if tmux split-window -h -c "$abs_worktree_dir" 2>/dev/null; then
            # Print final status with tmux message
            echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
            echo "  Location: $abs_worktree_dir"
            echo "  Opened in new tmux pane (current pane unchanged)"
        else
            # tmux command failed, fall back to regular behavior
            echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
            echo "  Location: $abs_worktree_dir"
            # Output the directory path for shell function to capture (hidden from normal output)
            echo "GITWORK_CD:$abs_worktree_dir" >&2
        fi
    else
        # Not in tmux, output directory for shell function to cd
        # Print final status
        echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
        echo "  Location: $abs_worktree_dir"
        
        # Output the directory path for shell function to capture (hidden from normal output)
        echo "GITWORK_CD:$abs_worktree_dir" >&2
    fi
}

# Subcommand: back
cmd_back() {
    # Check if we're in a worktree
    if ! is_worktree; then
        error "Not in a git worktree"
    fi
    
    # Get current directory name
    local current_dir
    current_dir=$(basename "$(pwd)")
    
    # Parse repository name from worktree directory pattern
    if [[ "$current_dir" =~ ^(.+)--(.+)$ ]]; then
        local repo_name="${BASH_REMATCH[1]}"
        local target_dir="../$repo_name"
        
        if [ ! -d "$target_dir" ]; then
            error "Main repository not found at: $target_dir"
        fi
        
        # Get absolute path for the main repository
        local abs_target_dir
        abs_target_dir=$(cd "$target_dir" && pwd)
        
        info "Returning to main repository: $repo_name"
        
        echo -e "${GREEN}✓${NC} Back to main repository"
        echo "  Location: $abs_target_dir"
        
        # Output the directory path for shell function to capture (hidden from normal output)
        echo "GITWORK_CD:$abs_target_dir" >&2
    else
        error "Current directory doesn't match expected pattern: <repo>--<branch>"
    fi
}

# Subcommand: finish
cmd_finish() {
    local branch_or_num="${1:-}"
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
    fi
    
    local worktree_path
    local branch_name
    local current_dir
    current_dir=$(pwd)
    local in_worktree=false
    
    # Check if we're in a worktree
    if is_worktree; then
        in_worktree=true
    fi
    
    # Determine which worktree to remove
    if [ -z "$branch_or_num" ]; then
        # No argument provided - remove current worktree
        if ! $in_worktree; then
            error "Not in a git worktree. Specify a branch name or number to remove."
        fi
        
        worktree_path=$(git rev-parse --show-toplevel)
        branch_name=$(git rev-parse --abbrev-ref HEAD)
    else
        # Argument provided - find the worktree to remove
        
        # Check if argument is a number
        if [[ "$branch_or_num" =~ ^[0-9]+$ ]]; then
            # Get worktree by number
            local worktrees
            worktrees=$(list_worktrees)
            
            if [ -z "$worktrees" ]; then
                error "No worktrees found"
            fi
            
            # Get the specific line by number
            local selected_line
            selected_line=$(echo "$worktrees" | sed -n "${branch_or_num}p")
            
            if [ -z "$selected_line" ]; then
                error "Invalid worktree number: $branch_or_num"
            fi
            
            # Extract path and branch from the selected line
            worktree_path=$(echo "$selected_line" | cut -d'|' -f2)
            branch_name=$(echo "$selected_line" | cut -d'|' -f1)
        else
            # Treat as branch name
            branch_name="$branch_or_num"
            worktree_path=$(get_worktree_path "$branch_name")
            
            if [ -z "$worktree_path" ]; then
                error "No worktree found for branch '$branch_name'"
            fi
        fi
    fi
    
    # Get main repository path
    local main_repo_path
    if $in_worktree; then
        main_repo_path=$(git rev-parse --git-common-dir | sed 's/\.git\/worktrees\/.*//')
    else
        main_repo_path=$(git rev-parse --show-toplevel)
    fi
    
    # If we're removing a different worktree than the current one, we need to check it
    if [ "$worktree_path" != "$current_dir" ]; then
        # Save current directory to return later if needed
        local return_to_dir="$current_dir"
        
        # Move to the worktree to check for uncommitted changes
        cd "$worktree_path" || error "Failed to access worktree at: $worktree_path"
        
        # Check for uncommitted changes
        if ! git diff --quiet || ! git diff --cached --quiet; then
            warn "The worktree for branch '$branch_name' has uncommitted changes"
            echo "Please commit or stash changes before finishing."
            cd "$return_to_dir"
            exit 1
        fi
        
        # Check for unpushed commits
        local unpushed_commits
        unpushed_commits=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        
        if [ "$unpushed_commits" != "0" ]; then
            warn "Branch '$branch_name' has $unpushed_commits unpushed commit(s)"
            echo "Consider pushing changes before finishing."
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Finish cancelled"
                cd "$return_to_dir"
                exit 0
            fi
        fi
        
        # Return to original directory
        cd "$return_to_dir"
    else
        # We're removing the current worktree
        
        # Check for uncommitted changes
        if ! git diff --quiet || ! git diff --cached --quiet; then
            warn "You have uncommitted changes in the worktree"
            echo "Please commit or stash your changes before finishing."
            exit 1
        fi
        
        # Check for unpushed commits
        local unpushed_commits
        unpushed_commits=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        
        if [ "$unpushed_commits" != "0" ]; then
            warn "You have $unpushed_commits unpushed commit(s)"
            echo "Consider pushing your changes before finishing."
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Finish cancelled"
                exit 0
            fi
        fi
    fi
    
    info "Finishing work on branch '$branch_name'"
    
    # If we're in the worktree being removed, move to main repository first
    if [ "$worktree_path" = "$current_dir" ]; then
        cd "$main_repo_path" || error "Failed to change to main repository"
    fi
    
    # Remove the worktree
    info "Removing worktree at: $worktree_path"
    git worktree remove "$worktree_path" --force || \
        error "Failed to remove worktree. You may need to manually run: git worktree remove \"$worktree_path\""
    
    echo -e "${GREEN}✓${NC} Successfully finished work on branch '$branch_name'"
    echo "  Worktree removed: $worktree_path"
    
    # If we were in the removed worktree, output new location
    if [ "$worktree_path" = "$current_dir" ]; then
        echo "  Current location: $main_repo_path"
        # Output the directory path for shell function to capture (hidden from normal output)
        echo "GITWORK_CD:$main_repo_path" >&2
        
        # If in tmux and no arguments were provided (removing current worktree), close the pane
        if [ -n "${TMUX:-}" ] && [ -z "$branch_or_num" ]; then
            info "Closing tmux pane and returning to first pane"
            # Kill current pane and select first pane in the window
            tmux kill-pane \; select-pane -t 0
        fi
    fi
}

# Subcommand: list
cmd_list() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
    fi
    
    # Check if --porcelain option is used
    if [[ "$*" == *"--porcelain"* ]]; then
        # Pass through to git worktree list for porcelain output
        git worktree list "$@"
        return
    fi
    
    # Custom numbered list output
    local worktrees
    worktrees=$(list_worktrees)
    
    if [ -z "$worktrees" ]; then
        echo "No worktrees found"
        return
    fi
    
    local current_dir
    current_dir=$(pwd)
    
    echo "Git worktrees:"
    echo
    
    local i=1
    while IFS='|' read -r branch path hash; do
        if [ "$path" = "$current_dir" ]; then
            echo "  $i) $branch (current)"
        else
            echo "  $i) $branch"
        fi
        echo "     Path: $path"
        ((i++))
    done <<< "$worktrees"
}

# Subcommand: move
cmd_move() {
    local branch_or_num="${1:-}"
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
    fi
    
    # Branch argument is required
    if [ -z "$branch_or_num" ]; then
        error "Branch name or number required. See '$SCRIPT_NAME move --help'"
    fi
    
    # Get current directory for comparison
    local current_dir
    current_dir=$(pwd)
    
    local worktree_path
    local branch_name
    
    # Check if argument is a number
    if [[ "$branch_or_num" =~ ^[0-9]+$ ]]; then
        # Get worktree by number
        local worktrees
        worktrees=$(list_worktrees)
        
        if [ -z "$worktrees" ]; then
            error "No worktrees found"
        fi
        
        # Get the specific line by number
        local selected_line
        selected_line=$(echo "$worktrees" | sed -n "${branch_or_num}p")
        
        if [ -z "$selected_line" ]; then
            error "Invalid worktree number: $branch_or_num"
        fi
        
        # Extract path and branch from the selected line
        worktree_path=$(echo "$selected_line" | cut -d'|' -f2)
        branch_name=$(echo "$selected_line" | cut -d'|' -f1)
    else
        # Treat as branch name
        branch_name="$branch_or_num"
        worktree_path=$(get_worktree_path "$branch_name")
        
        if [ -z "$worktree_path" ]; then
            error "No worktree found for branch '$branch_name'"
        fi
    fi
    
    if [ "$worktree_path" = "$current_dir" ]; then
        warn "Already in worktree for branch '$branch_name'"
        exit 0
    fi
    
    info "Moving to worktree for branch '$branch_name'"
    echo -e "${GREEN}✓${NC} Moved to worktree"
    echo "  Branch: $branch_name"
    echo "  Location: $worktree_path"
    
    # Output the directory path for shell function to capture
    echo "GITWORK_CD:$worktree_path" >&2
}

# Main command router
main() {
    local subcommand="${1:-}"
    
    case "$subcommand" in
        start)
            shift
            cmd_start "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        move)
            shift
            cmd_move "$@"
            ;;
        back)
            shift
            cmd_back "$@"
            ;;
        finish)
            shift
            cmd_finish "$@"
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        -v|--version|version)
            echo "$SCRIPT_NAME version $VERSION"
            exit 0
            ;;
        "")
            error "No command specified. See '$SCRIPT_NAME --help'"
            ;;
        *)
            error "Unknown command: $subcommand. See '$SCRIPT_NAME --help'"
            ;;
    esac
}

# Execute main function with all arguments
main "$@"