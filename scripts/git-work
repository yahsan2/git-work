#!/usr/bin/env bash
set -euo pipefail

# git-work - Git worktree management tool with tmux integration
# Version: 1.0.0

SCRIPT_NAME="git work"
VERSION="1.0.0"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${GREEN}→${NC} $1"
}

warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

usage() {
    cat << EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
  start <branch|origin/branch> [dir] [base]
    Create a new worktree for the specified branch
    
    Arguments:
      branch         Local branch name or origin/branch for remote branch
      dir            Worktree directory (default: ../<repo>--<branch>)
      base           Base branch for new branches (default: HEAD or origin/main)
    
    Examples:
      git work start feature-x                    # New branch from HEAD
      git work start origin/feature-y             # From remote branch
      git work start hotfix ../hotfix-dir main    # Custom dir and base
  
  back
    Return to the main repository from a worktree
    (Assumes worktree naming pattern: <repo>--<branch>)

Version: $VERSION
EOF
}

# Get repository name from current directory
get_repo_name() {
    local repo_path
    repo_path=$(git rev-parse --show-toplevel 2>/dev/null) || error "Not in a git repository"
    basename "$repo_path"
}

# Sanitize branch name for directory naming
sanitize_branch_name() {
    echo "$1" | sed 's/\//-/g'
}

# Check if branch exists locally
branch_exists() {
    git show-ref --verify --quiet "refs/heads/$1"
}

# Check if we're in a worktree
is_worktree() {
    git rev-parse --is-inside-work-tree &>/dev/null && \
    [ -n "$(git rev-parse --git-common-dir 2>/dev/null)" ] && \
    [ "$(git rev-parse --git-common-dir)" != "$(git rev-parse --git-dir)" ]
}

# Subcommand: start
cmd_start() {
    local branch_arg="${1:-}"
    local dir_arg="${2:-}"
    local base_arg="${3:-}"
    
    [ -z "$branch_arg" ] && error "Branch name required. See '$SCRIPT_NAME --help'"
    
    local repo_name
    repo_name=$(get_repo_name)
    
    local branch_name
    local needs_fetch=false
    local needs_create=false
    local remote_branch=""
    
    # Parse branch argument
    if [[ "$branch_arg" =~ ^origin/(.+)$ ]]; then
        # Remote branch specified
        branch_name="${BASH_REMATCH[1]}"
        remote_branch="origin/$branch_name"
        needs_fetch=true
        
        info "Fetching remote branch: $remote_branch"
        git fetch origin "$branch_name" || error "Failed to fetch $remote_branch"
        
        if ! branch_exists "$branch_name"; then
            needs_create=true
        fi
    else
        # Local branch specified
        branch_name="$branch_arg"
        
        if ! branch_exists "$branch_name"; then
            needs_create=true
            
            # Determine base branch
            if [ -z "$base_arg" ]; then
                # Try origin/main first, then current HEAD
                if git show-ref --verify --quiet "refs/remotes/origin/main"; then
                    base_arg="origin/main"
                    info "Using origin/main as base branch"
                else
                    base_arg="HEAD"
                    info "Using current HEAD as base branch"
                fi
            fi
            
            # Fetch base if it's a remote branch
            if [[ "$base_arg" =~ ^origin/(.+)$ ]]; then
                info "Fetching base branch: $base_arg"
                git fetch origin "${BASH_REMATCH[1]}" || error "Failed to fetch $base_arg"
            fi
        fi
    fi
    
    # Determine worktree directory
    local worktree_dir
    if [ -n "$dir_arg" ]; then
        worktree_dir="$dir_arg"
    else
        local sanitized_branch
        sanitized_branch=$(sanitize_branch_name "$branch_name")
        worktree_dir="../${repo_name}--${sanitized_branch}"
    fi
    
    # Create worktree
    if [ -d "$worktree_dir" ]; then
        error "Directory already exists: $worktree_dir"
    fi
    
    if [ "$needs_create" = true ]; then
        if [ -n "$remote_branch" ]; then
            # Create from remote branch
            info "Creating worktree with new branch '$branch_name' from '$remote_branch'"
            git worktree add -b "$branch_name" "$worktree_dir" "$remote_branch" || \
                error "Failed to create worktree"
        else
            # Create from base
            info "Creating worktree with new branch '$branch_name' from '$base_arg'"
            git worktree add -b "$branch_name" "$worktree_dir" "$base_arg" || \
                error "Failed to create worktree"
        fi
    else
        # Use existing branch
        info "Creating worktree for existing branch '$branch_name'"
        git worktree add "$worktree_dir" "$branch_name" || \
            error "Failed to create worktree"
    fi
    
    info "Worktree created at: $worktree_dir"
    
    # Get absolute path for the worktree
    local abs_worktree_dir
    abs_worktree_dir=$(cd "$worktree_dir" && pwd)
    
    # Open tmux pane if in tmux session
    if [ -n "${TMUX:-}" ]; then
        info "Opening new tmux pane in worktree directory"
        tmux split-window -h -c "$abs_worktree_dir"
    fi
    
    # Print final status
    echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
    echo "  Location: $abs_worktree_dir"
    
    # Output the directory path for shell function to capture (hidden from normal output)
    echo "GITWORK_CD:$abs_worktree_dir" >&2
}

# Subcommand: back
cmd_back() {
    # Check if we're in a worktree
    if ! is_worktree; then
        error "Not in a git worktree"
    fi
    
    # Get current directory name
    local current_dir
    current_dir=$(basename "$(pwd)")
    
    # Parse repository name from worktree directory pattern
    if [[ "$current_dir" =~ ^(.+)--(.+)$ ]]; then
        local repo_name="${BASH_REMATCH[1]}"
        local target_dir="../$repo_name"
        
        if [ ! -d "$target_dir" ]; then
            error "Main repository not found at: $target_dir"
        fi
        
        # Get absolute path for the main repository
        local abs_target_dir
        abs_target_dir=$(cd "$target_dir" && pwd)
        
        info "Returning to main repository: $repo_name"
        
        echo -e "${GREEN}✓${NC} Back to main repository"
        echo "  Location: $abs_target_dir"
        
        # Output the directory path for shell function to capture (hidden from normal output)
        echo "GITWORK_CD:$abs_target_dir" >&2
    else
        error "Current directory doesn't match expected pattern: <repo>--<branch>"
    fi
}

# Main command router
main() {
    local subcommand="${1:-}"
    
    case "$subcommand" in
        start)
            shift
            cmd_start "$@"
            ;;
        back)
            shift
            cmd_back "$@"
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        -v|--version|version)
            echo "$SCRIPT_NAME version $VERSION"
            exit 0
            ;;
        "")
            error "No command specified. See '$SCRIPT_NAME --help'"
            ;;
        *)
            error "Unknown command: $subcommand. See '$SCRIPT_NAME --help'"
            ;;
    esac
}

# Execute main function with all arguments
main "$@"