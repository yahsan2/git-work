#!/usr/bin/env bash
set -euo pipefail

# git-work - Git worktree management tool with tmux integration
# Version: 1.0.0

SCRIPT_NAME="git work"
VERSION="1.0.0"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Helper functions
error() {
    echo -e "${RED}Error: $1${NC}" >&2
    exit 1
}

info() {
    echo -e "${GREEN}→${NC} $1"
}

warn() {
    echo -e "${YELLOW}Warning: $1${NC}" >&2
}

usage() {
    cat << EOF
Usage: $SCRIPT_NAME <command> [options]

Commands:
  start <branch|origin/branch> [dir] [base]
    Create a new worktree for the specified branch
    
    Arguments:
      branch         Local branch name or origin/branch for remote branch
      dir            Worktree directory (default: ../<repo>--<branch>)
      base           Base branch for new branches (default: HEAD or origin/main)
    
    Examples:
      git work start feature-x                    # New branch from HEAD
      git work start origin/feature-y             # From remote branch
      git work start hotfix ../hotfix-dir main    # Custom dir and base
  
  list
    List all worktrees (alias for git worktree list)
    
    Examples:
      git work list                                # List all worktrees
      git work list --porcelain                    # Machine-readable format
  
  move <branch|number>
    Move to a different worktree
    
    Arguments:
      branch         Branch name or worktree number from list (required)
    
    Examples:
      git work move feature-x                     # Move to specific branch
      git work move 1                             # Move to worktree number 1 from list (0-based)
  
  back
    Return to the main repository from a worktree
    (Assumes worktree naming pattern: <repo>--<branch>)
  
  finish [branch|number]
    Remove a worktree and return to the main repository
    
    Arguments:
      branch         Branch name or worktree number from list (optional)
                     If not specified, removes current worktree
    
    Examples:
      git work finish                             # Remove current worktree
      git work finish feature-x                   # Remove specific branch's worktree
      git work finish 1                           # Remove worktree number 1 from list (0-based)

Version: $VERSION
EOF
}

# Get repository name from current directory
get_repo_name() {
    local repo_path
    repo_path=$(git rev-parse --show-toplevel 2>/dev/null) || error "Not in a git repository"
    basename "$repo_path"
}

# Sanitize branch name for directory naming
sanitize_branch_name() {
    echo "$1" | sed 's/\//-/g'
}

# Check if branch exists locally
branch_exists() {
    git show-ref --verify --quiet "refs/heads/$1"
}

# Check if we're in a worktree
is_worktree() {
    git rev-parse --is-inside-work-tree &>/dev/null && \
    [ -n "$(git rev-parse --git-common-dir 2>/dev/null)" ] && \
    [ "$(git rev-parse --git-common-dir)" != "$(git rev-parse --git-dir)" ]
}

# Get worktree path for a given branch
get_worktree_path() {
    local branch="$1"
    git worktree list --porcelain | awk -v branch="$branch" '
        /^worktree / { path = $2 }
        /^branch / && $2 == "refs/heads/" branch { print path; exit }
    '
}

# Check if tmux is responsive (quick test)
is_tmux_responsive() {
    if [ -n "${TMUX:-}" ]; then
        # Try a simple command first
        tmux display-message -p "test" >/dev/null 2>&1
        return $?
    fi
    return 1
}

# Find tmux pane by title
find_tmux_pane_by_title() {
    local title="$1"
    if [ -n "${TMUX:-}" ] && is_tmux_responsive; then
        # List all panes with their titles and IDs
        # Format: pane_id:pane_title
        local panes
        panes=$(tmux list-panes -a -F '#{pane_id}:#{pane_title}' 2>/dev/null || true)
        if [ -n "$panes" ]; then
            echo "$panes" | grep -F ":$title" | cut -d: -f1 | head -1
        fi
    fi
}

# Switch to tmux pane by ID
switch_to_tmux_pane() {
    local pane_id="$1"
    if [ -n "$pane_id" ] && is_tmux_responsive; then
        # Switch to the pane
        tmux switch-client -t "$pane_id" 2>/dev/null || tmux select-pane -t "$pane_id" 2>/dev/null
        return $?
    fi
    return 1
}

# Count tmux panes in current window
count_tmux_panes() {
    if [ -n "${TMUX:-}" ] && is_tmux_responsive; then
        local count
        count=$(tmux list-panes 2>/dev/null | wc -l | tr -d ' ' || echo "0")
        echo "$count"
    else
        echo "0"
    fi
}

# Get the right pane when there are 2 panes (returns pane index)
get_right_pane() {
    if [ -n "${TMUX:-}" ] && is_tmux_responsive; then
        # Get the pane on the right (higher x position)
        local panes
        panes=$(tmux list-panes -F '#{pane_index}:#{pane_left}' 2>/dev/null || true)
        if [ -n "$panes" ]; then
            echo "$panes" | sort -t: -k2 -nr | head -1 | cut -d: -f1
        fi
    fi
}

# List all worktrees with formatting
list_worktrees() {
    git worktree list | while read -r path hash rest; do
        # Extract branch name from [branch] format
        if [[ "$rest" =~ \[([^\]]+)\] ]]; then
            local branch="${BASH_REMATCH[1]}"
            echo "$branch|$path|$hash"
        fi
    done
}

# Subcommand: start
cmd_start() {
    local branch_arg="${1:-}"
    local dir_arg="${2:-}"
    local base_arg="${3:-}"
    
    [ -z "$branch_arg" ] && error "Branch name required. See '$SCRIPT_NAME --help'"
    
    local repo_name
    repo_name=$(get_repo_name)
    
    local branch_name
    local needs_fetch=false
    local needs_create=false
    local remote_branch=""
    
    # Parse branch argument
    if [[ "$branch_arg" =~ ^origin/(.+)$ ]]; then
        # Remote branch specified
        branch_name="${BASH_REMATCH[1]}"
        remote_branch="origin/$branch_name"
        needs_fetch=true
        
        info "Fetching remote branch: $remote_branch"
        git fetch origin "$branch_name" || error "Failed to fetch $remote_branch"
        
        if ! branch_exists "$branch_name"; then
            needs_create=true
        fi
    else
        # Local branch specified
        branch_name="$branch_arg"
        
        if ! branch_exists "$branch_name"; then
            needs_create=true
            
            # Determine base branch
            if [ -z "$base_arg" ]; then
                # Try origin/main first, then current HEAD
                if git show-ref --verify --quiet "refs/remotes/origin/main"; then
                    base_arg="origin/main"
                    info "Using origin/main as base branch"
                else
                    base_arg="HEAD"
                    info "Using current HEAD as base branch"
                fi
            fi
            
            # Fetch base if it's a remote branch
            if [[ "$base_arg" =~ ^origin/(.+)$ ]]; then
                info "Fetching base branch: $base_arg"
                git fetch origin "${BASH_REMATCH[1]}" || error "Failed to fetch $base_arg"
            fi
        fi
    fi
    
    # Determine worktree directory
    local worktree_dir
    if [ -n "$dir_arg" ]; then
        worktree_dir="$dir_arg"
    else
        local sanitized_branch
        sanitized_branch=$(sanitize_branch_name "$branch_name")
        worktree_dir="../${repo_name}--${sanitized_branch}"
    fi
    
    # Create worktree
    if [ -d "$worktree_dir" ]; then
        error "Directory already exists: $worktree_dir"
    fi
    
    if [ "$needs_create" = true ]; then
        if [ -n "$remote_branch" ]; then
            # Create from remote branch
            info "Creating worktree with new branch '$branch_name' from '$remote_branch'"
            git worktree add -b "$branch_name" "$worktree_dir" "$remote_branch" || \
                error "Failed to create worktree"
        else
            # Create from base
            info "Creating worktree with new branch '$branch_name' from '$base_arg'"
            git worktree add -b "$branch_name" "$worktree_dir" "$base_arg" || \
                error "Failed to create worktree"
        fi
    else
        # Use existing branch
        info "Creating worktree for existing branch '$branch_name'"
        git worktree add "$worktree_dir" "$branch_name" || \
            error "Failed to create worktree"
    fi
    
    info "Worktree created at: $worktree_dir"
    
    # Get absolute path for the worktree
    local abs_worktree_dir
    abs_worktree_dir=$(cd "$worktree_dir" && pwd)
    
    # Open tmux pane if in tmux session
    if [ -n "${TMUX:-}" ] && is_tmux_responsive; then
        info "Opening new tmux pane in worktree directory"
        # Set current pane title to [main] if not already in a worktree
        if ! is_worktree; then
            tmux select-pane -T "[main]" 2>/dev/null || true
        fi
        
        # Check pane count to determine split direction
        local pane_count
        pane_count=$(count_tmux_panes)
        
        local split_succeeded=false
        if [ "$pane_count" = "2" ]; then
            # If there are exactly 2 panes, split vertically below the right pane
            local right_pane
            right_pane=$(get_right_pane)
            if [ -n "$right_pane" ]; then
                info "Creating pane below the right pane"
                if tmux split-window -v -t "$right_pane" -c "$abs_worktree_dir" 2>/dev/null; then
                    split_succeeded=true
                fi
            fi
        fi
        
        # If not 2 panes or vertical split failed, use horizontal split
        if ! $split_succeeded; then
            if tmux split-window -h -c "$abs_worktree_dir" 2>/dev/null; then
                split_succeeded=true
            fi
        fi
        
        if $split_succeeded; then
            # Set new pane title to branch name
            tmux select-pane -T "[$branch_name]" -t '{last}' 2>/dev/null || true
            # Print final status with tmux message
            echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
            echo "  Location: $abs_worktree_dir"
            if [ "$pane_count" = "2" ]; then
                echo "  Opened in new tmux pane below right pane with title: [$branch_name]"
            else
                echo "  Opened in new tmux pane with title: [$branch_name]"
            fi
        else
            # tmux command failed, fall back to regular behavior
            echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
            echo "  Location: $abs_worktree_dir"
            # Output the directory path for shell function to capture (hidden from normal output)
            echo "GITWORK_CD:$abs_worktree_dir" >&2
        fi
    else
        # Not in tmux, output directory for shell function to cd
        # Print final status
        echo -e "${GREEN}✓${NC} Successfully started work on branch '$branch_name'"
        echo "  Location: $abs_worktree_dir"
        
        # Output the directory path for shell function to capture (hidden from normal output)
        echo "GITWORK_CD:$abs_worktree_dir" >&2
    fi
}

# Subcommand: back
cmd_back() {
    # Check if we're in a worktree
    if ! is_worktree; then
        error "Not in a git worktree"
    fi
    
    # Get current directory name
    local current_dir
    current_dir=$(basename "$(pwd)")
    
    # Parse repository name from worktree directory pattern
    if [[ "$current_dir" =~ ^(.+)--(.+)$ ]]; then
        local repo_name="${BASH_REMATCH[1]}"
        local target_dir="../$repo_name"
        
        if [ ! -d "$target_dir" ]; then
            error "Main repository not found at: $target_dir"
        fi
        
        # Get absolute path for the main repository
        local abs_target_dir
        abs_target_dir=$(cd "$target_dir" && pwd)
        
        info "Returning to main repository: $repo_name"
        
        # If in tmux, close the pane and return to first pane
        if [ -n "${TMUX:-}" ] && is_tmux_responsive; then
            echo -e "${GREEN}✓${NC} Back to main repository"
            echo "  Location: $abs_target_dir"
            echo "  Closing tmux pane and returning to first pane"
            
            # Output the directory path for shell function to capture (hidden from normal output)
            echo "GITWORK_CD:$abs_target_dir" >&2
            
            # Kill current pane and select first pane in the window
            tmux kill-pane \; select-pane -t 0 2>/dev/null || true
        else
            echo -e "${GREEN}✓${NC} Back to main repository"
            echo "  Location: $abs_target_dir"
            
            # Output the directory path for shell function to capture (hidden from normal output)
            echo "GITWORK_CD:$abs_target_dir" >&2
        fi
    else
        error "Current directory doesn't match expected pattern: <repo>--<branch>"
    fi
}

# Subcommand: finish
cmd_finish() {
    local branch_or_num="${1:-}"
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
    fi
    
    local worktree_path
    local branch_name
    local current_dir
    current_dir=$(pwd)
    local in_worktree=false
    
    # Check if we're in a worktree
    if is_worktree; then
        in_worktree=true
    fi
    
    # Determine which worktree to remove
    if [ -z "$branch_or_num" ]; then
        # No argument provided - remove current worktree
        if ! $in_worktree; then
            error "Not in a git worktree. Specify a branch name or number to remove."
        fi
        
        worktree_path=$(git rev-parse --show-toplevel)
        branch_name=$(git rev-parse --abbrev-ref HEAD)
    else
        # Argument provided - find the worktree to remove
        
        # Check if argument is a number
        if [[ "$branch_or_num" =~ ^[0-9]+$ ]]; then
            # Get worktree by number (0-based indexing)
            local worktrees
            worktrees=$(list_worktrees)
            
            if [ -z "$worktrees" ]; then
                error "No worktrees found"
            fi
            
            # Get the specific line by number (convert 0-based to 1-based for sed)
            local line_num=$((branch_or_num + 1))
            local selected_line
            selected_line=$(echo "$worktrees" | sed -n "${line_num}p")
            
            if [ -z "$selected_line" ]; then
                error "Invalid worktree number: $branch_or_num"
            fi
            
            # Extract path and branch from the selected line
            worktree_path=$(echo "$selected_line" | cut -d'|' -f2)
            branch_name=$(echo "$selected_line" | cut -d'|' -f1)
        else
            # Treat as branch name
            branch_name="$branch_or_num"
            worktree_path=$(get_worktree_path "$branch_name")
            
            if [ -z "$worktree_path" ]; then
                error "No worktree found for branch '$branch_name'"
            fi
        fi
    fi
    
    # Get main repository path
    local main_repo_path
    if $in_worktree; then
        main_repo_path=$(git rev-parse --git-common-dir | sed 's/\.git\/worktrees\/.*//')
    else
        main_repo_path=$(git rev-parse --show-toplevel)
    fi
    
    # If we're removing a different worktree than the current one, we need to check it
    if [ "$worktree_path" != "$current_dir" ]; then
        # Save current directory to return later if needed
        local return_to_dir="$current_dir"
        
        # Move to the worktree to check for uncommitted changes
        cd "$worktree_path" || error "Failed to access worktree at: $worktree_path"
        
        # Check for uncommitted changes
        if ! git diff --quiet || ! git diff --cached --quiet; then
            warn "The worktree for branch '$branch_name' has uncommitted changes"
            echo "Please commit or stash changes before finishing."
            cd "$return_to_dir"
            exit 1
        fi
        
        # Check for unpushed commits
        local unpushed_commits
        unpushed_commits=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        
        if [ "$unpushed_commits" != "0" ]; then
            warn "Branch '$branch_name' has $unpushed_commits unpushed commit(s)"
            echo "Consider pushing changes before finishing."
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Finish cancelled"
                cd "$return_to_dir"
                exit 0
            fi
        fi
        
        # Return to original directory
        cd "$return_to_dir"
    else
        # We're removing the current worktree
        
        # Check for uncommitted changes
        if ! git diff --quiet || ! git diff --cached --quiet; then
            warn "You have uncommitted changes in the worktree"
            echo "Please commit or stash your changes before finishing."
            exit 1
        fi
        
        # Check for unpushed commits
        local unpushed_commits
        unpushed_commits=$(git rev-list --count @{u}..HEAD 2>/dev/null || echo "0")
        
        if [ "$unpushed_commits" != "0" ]; then
            warn "You have $unpushed_commits unpushed commit(s)"
            echo "Consider pushing your changes before finishing."
            read -p "Continue anyway? [y/N] " -n 1 -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                info "Finish cancelled"
                exit 0
            fi
        fi
    fi
    
    info "Finishing work on branch '$branch_name'"
    
    # If we're in the worktree being removed, move to main repository first
    if [ "$worktree_path" = "$current_dir" ]; then
        cd "$main_repo_path" || error "Failed to change to main repository"
    fi
    
    # Remove the worktree
    info "Removing worktree at: $worktree_path"
    git worktree remove "$worktree_path" --force || \
        error "Failed to remove worktree. You may need to manually run: git worktree remove \"$worktree_path\""
    
    echo -e "${GREEN}✓${NC} Successfully finished work on branch '$branch_name'"
    echo "  Worktree removed: $worktree_path"
    
    # If we were in the removed worktree, output new location
    if [ "$worktree_path" = "$current_dir" ]; then
        echo "  Current location: $main_repo_path"
        # Output the directory path for shell function to capture (hidden from normal output)
        echo "GITWORK_CD:$main_repo_path" >&2
        
        # If in tmux and no arguments were provided (removing current worktree), close the pane
        if [ -n "${TMUX:-}" ] && [ -z "$branch_or_num" ] && is_tmux_responsive; then
            info "Closing tmux pane and returning to first pane"
            # Kill current pane and select first pane in the window
            tmux kill-pane \; select-pane -t 0 2>/dev/null || true
        fi
    fi
}

# Subcommand: list
cmd_list() {
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
    fi
    
    # Check if --porcelain option is used
    if [[ "$*" == *"--porcelain"* ]]; then
        # Pass through to git worktree list for porcelain output
        git worktree list "$@"
        return
    fi
    
    # Custom numbered list output
    local worktrees
    worktrees=$(list_worktrees)
    
    if [ -z "$worktrees" ]; then
        echo "No worktrees found"
        return
    fi
    
    local current_dir
    current_dir=$(pwd)
    
    echo "Git worktrees:"
    echo
    
    local i=0
    while IFS='|' read -r branch path hash; do
        if [ "$path" = "$current_dir" ]; then
            echo "  $i) $branch (current)"
        else
            echo "  $i) $branch"
        fi
        echo "     Path: $path"
        ((i++))
    done <<< "$worktrees"
}

# Subcommand: move
cmd_move() {
    local branch_or_num="${1:-}"
    
    # Check if we're in a git repository
    if ! git rev-parse --git-dir &>/dev/null; then
        error "Not in a git repository"
    fi
    
    # Branch argument is required
    if [ -z "$branch_or_num" ]; then
        error "Branch name or number required. See '$SCRIPT_NAME move --help'"
    fi
    
    # Get current directory for comparison
    local current_dir
    current_dir=$(pwd)
    
    local worktree_path
    local branch_name
    
    # Check if argument is a number
    if [[ "$branch_or_num" =~ ^[0-9]+$ ]]; then
        # Get worktree by number (0-based indexing)
        local worktrees
        worktrees=$(list_worktrees)
        
        if [ -z "$worktrees" ]; then
            error "No worktrees found"
        fi
        
        # Get the specific line by number (convert 0-based to 1-based for sed)
        local line_num=$((branch_or_num + 1))
        local selected_line
        selected_line=$(echo "$worktrees" | sed -n "${line_num}p")
        
        if [ -z "$selected_line" ]; then
            error "Invalid worktree number: $branch_or_num"
        fi
        
        # Extract path and branch from the selected line
        worktree_path=$(echo "$selected_line" | cut -d'|' -f2)
        branch_name=$(echo "$selected_line" | cut -d'|' -f1)
    else
        # Treat as branch name
        branch_name="$branch_or_num"
        worktree_path=$(get_worktree_path "$branch_name")
        
        if [ -z "$worktree_path" ]; then
            error "No worktree found for branch '$branch_name'"
        fi
    fi
    
    if [ "$worktree_path" = "$current_dir" ]; then
        warn "Already in worktree for branch '$branch_name'"
        exit 0
    fi
    
    # Check if we're in the main repository (not in a worktree)
    local in_main_repo=false
    if ! is_worktree; then
        in_main_repo=true
    fi
    
    info "Moving to worktree for branch '$branch_name'"
    
    # If in tmux, check if pane already exists for this branch
    if [ -n "${TMUX:-}" ] && is_tmux_responsive; then
        local existing_pane
        existing_pane=$(find_tmux_pane_by_title "[$branch_name]")
        
        if [ -n "$existing_pane" ]; then
            # Pane already exists, switch to it
            info "Found existing tmux pane for branch '$branch_name'"
            if switch_to_tmux_pane "$existing_pane"; then
                echo -e "${GREEN}✓${NC} Switched to existing pane"
                echo "  Branch: $branch_name"
                echo "  Location: $worktree_path"
                echo "  Switched to existing tmux pane: [$branch_name]"
                exit 0
            fi
        fi
        
        # No existing pane found, create new one if in main repo
        if $in_main_repo; then
            info "Opening new tmux pane in worktree directory"
            # Set current pane title to [main]
            tmux select-pane -T "[main]" 2>/dev/null || true
            
            # Check pane count to determine split direction
            local pane_count
            pane_count=$(count_tmux_panes)
            
            local split_succeeded=false
            if [ "$pane_count" = "2" ]; then
                # If there are exactly 2 panes, split vertically below the right pane
                local right_pane
                right_pane=$(get_right_pane)
                if [ -n "$right_pane" ]; then
                    info "Creating pane below the right pane"
                    if tmux split-window -v -t "$right_pane" -c "$worktree_path" 2>/dev/null; then
                        split_succeeded=true
                    fi
                fi
            fi
            
            # If not 2 panes or vertical split failed, use horizontal split
            if ! $split_succeeded; then
                if tmux split-window -h -c "$worktree_path" 2>/dev/null; then
                    split_succeeded=true
                fi
            fi
            
            if $split_succeeded; then
                # Set new pane title to branch name
                tmux select-pane -T "[$branch_name]" -t '{last}' 2>/dev/null || true
                echo -e "${GREEN}✓${NC} Moved to worktree"
                echo "  Branch: $branch_name"
                echo "  Location: $worktree_path"
                if [ "$pane_count" = "2" ]; then
                    echo "  Opened in new tmux pane below right pane with title: [$branch_name]"
                else
                    echo "  Opened in new tmux pane with title: [$branch_name]"
                fi
            else
                # tmux command failed, fall back to regular behavior
                echo -e "${GREEN}✓${NC} Moved to worktree"
                echo "  Branch: $branch_name"
                echo "  Location: $worktree_path"
                # Output the directory path for shell function to capture
                echo "GITWORK_CD:$worktree_path" >&2
            fi
        else
            # In worktree, use regular cd
            echo -e "${GREEN}✓${NC} Moved to worktree"
            echo "  Branch: $branch_name"
            echo "  Location: $worktree_path"
            # Output the directory path for shell function to capture
            echo "GITWORK_CD:$worktree_path" >&2
        fi
    else
        # Not in tmux or not in main repo, use regular cd
        echo -e "${GREEN}✓${NC} Moved to worktree"
        echo "  Branch: $branch_name"
        echo "  Location: $worktree_path"
        
        # Output the directory path for shell function to capture
        echo "GITWORK_CD:$worktree_path" >&2
    fi
}

# Main command router
main() {
    local subcommand="${1:-}"
    
    case "$subcommand" in
        start)
            shift
            cmd_start "$@"
            ;;
        list)
            shift
            cmd_list "$@"
            ;;
        move)
            shift
            cmd_move "$@"
            ;;
        back)
            shift
            cmd_back "$@"
            ;;
        finish)
            shift
            cmd_finish "$@"
            ;;
        -h|--help|help)
            usage
            exit 0
            ;;
        -v|--version|version)
            echo "$SCRIPT_NAME version $VERSION"
            exit 0
            ;;
        "")
            error "No command specified. See '$SCRIPT_NAME --help'"
            ;;
        *)
            error "Unknown command: $subcommand. See '$SCRIPT_NAME --help'"
            ;;
    esac
}

# Execute main function with all arguments
main "$@"